use std::collections::HashSet;
use std::iter::FromIterator;
use std::str::FromStr;

use num::{BigInt, BigRational, bigint::Sign};

use crate::ast::{Atom, ComparisonOp, FactorOp, SExpr};

grammar;

List<T>: Vec<T> = {
    <mut v:T*> <e:T> => {
        v.push(e);
        v
    }
};

pub SExprs = List<SExpr>;
Atoms = List<Atom>;

SExpr: Box<SExpr> = {
    "(" <SExprs> ")" => Box::new(SExpr::Expr(<>)),
    "#(" <SExprs> ")" => Box::new(SExpr::Lambda(<>)),
    "'(" <SExprs> ")" => Box::new(SExpr::List(<>)),
    "[" <SExprs> "]" => Box::new(SExpr::Vector(<>)),
    "#{" <Atoms> "}" => Box::new(SExpr::Set(HashSet::from_iter(<>))),
    Atom => Box::new(SExpr::Atom(<>)),
};

Atom: Box<Atom> = {
    "nil" => Box::new(Atom::Nil),
    "%" => Box::new(Atom::LambdaArg),
    ComparisonOp => Box::new(Atom::Comparison(<>)),
    FactorOp => Box::new(Atom::Factor(<>)),
    Identifier => Box::new(Atom::Identifier(<>)),
    StringLiteral => Box::new(Atom::String(<>)),
    DecimalLiteral => {
        let num_parts: Vec<&str> = <>.split(".").collect();
        let integer = BigInt::parse_bytes(num_parts[0].as_bytes(), 10).unwrap();
        let mut decimals = BigInt::parse_bytes(num_parts[1].as_bytes(), 10).unwrap();
        if integer.sign() == Sign::Minus {
            decimals *= -1;
        }
        let exp = num_parts[1].len() as u32;
        let numer = (integer * BigInt::from(10).pow(exp)) + decimals;
        let fraction = BigRational::new(numer, BigInt::from(10).pow(exp));
        Box::new(Atom::Number(fraction))
    },
    IntegerLiteral => {
        let fraction = BigRational::from_str(<>).unwrap();
        Box::new(Atom::Number(fraction))
    },
};

ComparisonOp: ComparisonOp = {
    "=" => ComparisonOp::Eq,
    "!=" => ComparisonOp::Ne,
    ">" => ComparisonOp::Gt,
    "<" => ComparisonOp::Lt,
    ">=" => ComparisonOp::Ge,
    "<=" => ComparisonOp::Le,
};

FactorOp: FactorOp = {
    "+" => FactorOp::Add,
    "-" => FactorOp::Sub,
    "*" => FactorOp::Mul,
    "/" => FactorOp::Div,
};

Identifier: String = r"[A-Za-z][A-Za-z0-9!?'_-]*" => String::from(<>);
StringLiteral: String = r#""[^"]*""# => {
    let mut chars = <>.chars();
    chars.next();
    chars.next_back();
    chars.as_str().to_owned()
};
IntegerLiteral: &'input str = r"[-]?[0-9]+" => <>;
DecimalLiteral: &'input str = r"[-]?[0-9]+\.[0-9]+" => <>;
