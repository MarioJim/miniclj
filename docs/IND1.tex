\documentclass[11pt]{scrreprt}
\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\addtokomafont{chapter}{\LARGE}
\renewcommand*{\chapterformat}{\thechapter\hspace{0.4cm}}
\RedeclareSectionCommand[style=section]{chapter}

\usepackage{graphicx}
\usepackage{sectsty}
\usepackage{titlesec}
\usepackage{url}
\usepackage{hyperref}

\usepackage{minted}
\usemintedstyle{borland}
\setminted{linenos=true,fontsize=\small}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in


\begin{document}

\begin{titlepage}
    \centering
    \vspace{4\baselineskip}
    Instituto Tecnológico y de Estudios Superiores de Monterrey\par
    Campus Monterrey\par
    \vspace{2\baselineskip}
    {\large
    TC-3048 Compiler design}\par
    \vspace{6\baselineskip}
    {\huge
    miniclj\par}
    {\LARGE
    Final documentation\par}
    \vspace{4\baselineskip}
    {\Large
    Mario Emilio Jiménez Vizcaíno\\ A01173359\par}
    \vfill
    Elda Guadalupe Quiroga\par
    Héctor Gibrán Ceballos\par
    \vspace{4\baselineskip}
    November 24th, 2021
\end{titlepage}

\pagebreak

\tableofcontents

\chapter{About the project}
\section{Project scope}
TODO

\section{Requirements}
TODO

\section{Development process}
The development of the language can be tracked from its GitHub repository here: \\\url{https://github.com/MarioJim/miniclj}. The list of commits since the last time this document was generated can also be found in appendix \ref{apdx:commits}.

\subsection{Weekly logs}
During the development I've also kept a weekly log in Spanish of my progress. It can be found in the README.md file in the root directory, or in appendix \ref{apdx:weeklylogs}.

\subsection{Final thoughts}
TODO


\chapter{About the language}
\section{Language name}
I chose the name \texttt{miniclj} because this project aims to be a Clojure clone, with a subset of the language's functionality. The syntax and expressions are similar to Clojure's, but some special commands and data structures aren't available, such as support for macros (\texttt{defmacro}), symbols (also known as identifiers, they replaced during compilation) and concurrency primitives (\texttt{atom}, \texttt{swap!}, \texttt{promise}, \texttt{deliver}).

\section{Language features}
\texttt{miniclj} offers the basic functionality of a lisp-based language, such as a language based on s-expressions and first-class support for lists and lambda functions. Other features inherited from Clojure are a couple more collections (vectors, sets and maps) and support for strings as vectors of characters.

\section{Errors}
The errors for each compilation and execution stage are the following:

\subsection{Parser errors}
This errors are the ones implemented by \texttt{lalrpop}, the parser generator library the language uses, and they are variants of the \href{https://github.com/lalrpop/lalrpop/blob/fc9986c725d908a60b11d8480711afa33f7f3564/lalrpop-util/src/lib.rs#L15}{enum \texttt{ParseError}, found in the file src/lib.rs from the lalrpop-util crate}.
\begin{itemize}
  \item \texttt{InvalidToken}: Returned when the parser encounters a token that isn't part of the language's grammar
  \item \texttt{UnrecognizedEOF}: Returned by the parser when it encounters an EOF it did not expect
  \item \texttt{UnrecognizedToken}: Returned when the parser encounters a token it didn't expect in that position
  \item \texttt{ExtraToken}: Returned when the parser encounters an additional, repeated token
  \item \texttt{User}: Returned by the parser when a custom validation doesn't pass. This type of error is can only be returned while parsing bytecode from its string representation during execution, when a builtin function isn't recognized or when a memory address couldn't be parsed correctly.
\end{itemize}

\subsection{Compiler errors}
This errors are implemented as variants of the \href{https://github.com/MarioJim/miniclj/blob/263ce60c5847511cdae9b27d79e5db1ae18759a2/miniclj-lib/src/compiler/error.rs#L10}{\texttt{CompilationError} enum, file \texttt{src/compiler/error.rs} in the \texttt{miniclj-lib} crate}.
\begin{itemize}
  \item \texttt{CallableNotDefined}: Returned when the compiler encounters a symbol that was supposed to be used as a callable, but isn't defined in the current scope (wasn't a user-defined function nor a builtin callable)
  \item \texttt{EmptyArgs}: Returned when a expression tried to call a callable with no arguments, and the callalbe expects at least one
  \item \texttt{SymbolNotDefined}: Returned by the compiler when a symbol wasn't defined in the current scope (or any other parent scope)
  \item \texttt{WrongArgument}: Returned by the compiler when a function receives an argument that it didn't expect. Although most functions don't check the type of its arguments during compilation, some functions with a custom compilation process (such as \texttt{fn}, \texttt{defn} and \texttt{let}) use their arguments during compilation
  \item \texttt{WrongArity}: Returned when the user tried to call a callable with the wrong number of arguments
  \item \texttt{WrongRecurCall}: Returned when the user tried to call the \texttt{recur} function with a different number of arguments than it's corresponding \texttt{loop} call
\end{itemize}

\subsection{Runtime errors}
This errors are implemented as variants of the \href{https://github.com/MarioJim/miniclj/blob/263ce60c5847511cdae9b27d79e5db1ae18759a2/miniclj-lib/src/vm/error.rs#L6}{\texttt{RuntimeError} enum, file \texttt{src/vm/error.rs} in the \texttt{miniclj-lib} crate}.
\begin{itemize}
  \item \texttt{CompilerError}: This variant of \texttt{RuntimeError} encloses any error that was caused by a compiler malfunction and should be encountered by the user if the compiler has a bug or if the bytecode was modified
  \item \texttt{CouldntParse}: This variant is returned when a value that was passed to a parsing function (like \texttt{num} and \texttt{chr}) couldn't be correctly processed
  \item \texttt{DivisionByZero}: Returned when the user tries to divide a number by zero
  \item \texttt{IndexOutOfBounds}: Returned when the user tries to get a value from an indexed collection using the callable \texttt{nth} and the collection is shorter than the index
  \item \texttt{InvalidMapEntry}: Returned when, inside a function, a value is implicitly casted to a map entry, but the value isn't a vector with two elements
  \item \texttt{IOError}: Returned when a input/output function returned an error instead of correctly printing/reading strings
  \item \texttt{NotACallable}: Returned when a value was tried be executed as a callable, but it wasn't a builtin function nor a user-defined callable
  \item \texttt{WrongArity}: This error has two variants (\texttt{WrongArityN} and \texttt{WrongArityS}), but both represent the same error: the user tried to call a callable with the wrong number of arguments
  \item \texttt{WrongDataType}: Returned when a callable receives a value with an incorrect datatype, that the callable didn't expect
\end{itemize}


\chapter{About the compiler}

\section{Tools and libraries}
The compiler is written in Rust, and it has a couple of dependencies:
\begin{itemize}
  \item \texttt{lalrpop}: used as a lexer and parser for the language
  \item \texttt{num}: used for its implementation of a fraction of 64 bit integers, \texttt{Rational64}
  \item \texttt{smol\_str}: this package is used to keep small strings (less than 22 bytes) in the stack instead of allocating them in the heap
\end{itemize}

\section{Lexer and Parser}
The grammar and tokens of the language are described in the file \path{miniclj-lib/src/lispparser.lalrpop}, included in appendix \ref{apdx:grammar}. It describes the following rules:
\begin{itemize}
  \item \texttt{SExprs}: A list of \texttt{SExpr}
  \item \texttt{SExpr}: This rule encompasses the types of expressions \texttt{miniclj} accepts:
  \begin{itemize}
    \item simple expressions (calls to a function with arguments)
    \item short lambdas (lambda functions where the argument is a \%)
    \item lists (implemented as linked lists)
    \item vectors (backed by an array)
    \item maps (backed by a hashmap)
    \item sets (backed by a hashset)
    \item simple literals (described the next rule)
  \end{itemize}
  Every expression but the last one accepts a list of s-expressions (rule \texttt{SExpr}) between its opening and closing sign.
  \item \texttt{Literal}: This rule has 4 different variants, and each one describes a different type of literal:
  \begin{itemize}
    \item \texttt{"nil"}, the nil value in \texttt{miniclj}
    \item \texttt{Symbol}
    \item \texttt{StringLiteral}
    \item \texttt{NumberLiteral}
  \end{itemize}
  \item \texttt{NumberLiteral}: This rule parses a number from a string, and is exposed to the language so that it can be used by calling the builtin function \texttt{num}. It has two variants:
  \begin{itemize}
    \item \texttt{r"[-]?[0-9]+.[0-9]+"}: this regular expression describes a decimal number, that is then parsed into a fraction
    \item \texttt{r"[-]?[0-9]+"}: this regular expression accepts integers, and is also parsed into a fraction with a denominator of 1
  \end{itemize}
  \item \texttt{List<T>}: This is a macro from \texttt{lalrpop}, and it is used to parse a list of parsers of type \texttt{T} separated by whitespace
  \item \texttt{Symbol}: This rule describes the different type of symbols \texttt{miniclj} accepts, and it has 4 variants:
  \begin{itemize}
    \item \texttt{"\%"}: The argument for a short lambda
    \item \texttt{ComparisonOp}
    \item \texttt{FactorOp}
    \item \texttt{r"[A-Za-z][A-Za-z0-9!?'\_-]*"}: this regular expression accepts most of the characters that can compose a symbol in Clojure, but I chose to discard some of them to simplify my language and reduce the parser conflicts. More information about symbols in Clojure can be found at \url{https://clojure.org/reference/reader#_symbols}
  \end{itemize}
  \item \texttt{ComparisonOp}: This rule includes the symbols used to compare values in \texttt{miniclj}. They are \texttt{=} (equals), \texttt{!=} (not equals), \texttt{>} (greater), \texttt{<} (less), \texttt{>=} (greater or equal) and \texttt{<=} (less or equal)
  \item \texttt{FactorOp}: This rule includes the basic math operations: \texttt{+} (addition), \texttt{-} (subtraction), \texttt{*} (multiplication) and \texttt{/} (division)
  \item \texttt{StringLiteral}: This last rule describes a string between double quotes
\end{itemize}

\section{Compiler state}
The compiler state is enclosed inside the \texttt{CompilerState} struct, inside file \path{miniclj-lib/src/compiler/state.rs}.

This structure is composed of 5 data structures:
\begin{itemize}
  \item \texttt{constants}: This hashmap stores the relationships between the constants and their memory addresses. I decided to use a map instead of a vector so that repeated constants occupy the same address. This map is accessed by the following methods of the \texttt{CompilerState} struct:
  \begin{itemize}
    \item \texttt{insert\_constant}: Receives a constant and returns a memory address. This method has two branches: when the constant was already added to the constants map, this metod just returns a copy of the address assigned to the constant. In case the constant wasn't found in the constants table, the compiler finds the next address available by iterating through the map and inserts the constant with that address.
  \end{itemize}
  \item \texttt{instructions}: This vector stores the list of instructions that will be later executed by the VM. It is accessed by the following methods:
  \begin{itemize}
    \item \texttt{add\_instruction}: Receives an instruction, appends it to the vector, and returns the index of the new instruction
    \item \texttt{instruction\_ptr}: Returns the length of the instructions vector, used as the index of the following instruction to be inserted
    \item \texttt{fill\_jump}: Receives two instruction pointers: the first one is the index of the jump instruction to be modified, and the second one the instruction that it should point to. If the first instruction pointer doesn't refer to a jump instruction, the compiler crashes.
  \end{itemize}
  \item \texttt{symbol\_table}: This custom structure, described in file \texttt{miniclj-lib/src/compiler/\\symboltable.rs} and implemented as a linked list, has three fields:
  \begin{itemize}
    \item \texttt{symbols}: A hashmap of identifiers (declared inside the current scope) to memory addresses
    \item \texttt{temp\_counter}: A counter of how many temporal variables have been created in the current scope
    \item \texttt{var\_counter}: A counter of how many local variables have been assigned in the current scope
  \end{itemize}
  This data structure is accessed by the following methods:
  \begin{itemize}
    \item \texttt{get\_symbol}: Receives a reference to a string and returns either the memory address that points to the value of the identifier or no memory address in case that the symbol couldn't be found in the scope
    \item \texttt{new\_address}: Receives a \texttt{Lifetime} variant to determine if the new address should be a temporal, local or global address, and returns a new memory address
    \item \texttt{insert\_symbol}: Receives a string and an address, and inserts them into the corresponding symbol table (either the current symbol table if the address is local, or the global symbol table if the address has a global lifetime)
    \item \texttt{remove\_symbol}: Receives a reference to a string and removes the symbol from the scope
  \end{itemize}
  \item \texttt{loop\_jumps\_stack}: This structure, although represented as a vector, is used as a stack of pairs of instruction pointers and vectors of memory addresses. This stack is useful for loop/recur cycles, where the compiler has to check where was the last \texttt{loop} instruction declared, so that when a \texttt{recur} instruction is found:
  \begin{enumerate}
    \item The compiler can check that it has the same number of arguments
    \item It can copy the value from each argument to the memory address of the \texttt{loop}'s declaration
    \item It can emit the goto instruction to the \texttt{loop} instruction
  \end{enumerate}
  This process is documented in file \path{miniclj-lib/src/callables/scopefns.rs}, and\\\texttt{CompilerState} exposes the following methods to modify the \texttt{loop\_jumps\_stack}:
  \begin{itemize}
    \item \texttt{push\_loop\_jump}: Receives an instruction pointer and a vector of memory addresses, and appends the pair to the stack
    \item \texttt{pop\_loop\_jump}: Returns a pair of instruction pointer and vector of memory addresses, or nothing if the stack is empty
  \end{itemize}
  \item \texttt{callables\_table}: This custom structure, implemented as a map between strings and structs that implement the \texttt{Callable} trait. It is declared in file \path{miniclj-lib/src/callables/mod.rs}, and it is used to manage the compilation for callables, that consists of:
  \begin{itemize}
    \item For most callables, compile the arguments, add the callable to the constants table and emit an \texttt{Call} instruction for the callable's address, the resulting address of each argument and the temporal address where the result of the call will be stored.
    \item For the other callables, each one may have a different, custom compilation process, like the ones that modify the scope (\texttt{def}, \texttt{defn}, \texttt{let}), the ones used as cycles (\texttt{loop}, \texttt{recur}) and others (like \texttt{fn})
  \end{itemize}
\end{itemize}

This structure also exposes a couple of methods that are use throughout the compilation process:
\begin{itemize}
  \item \texttt{compile}: This is the main method of the compiler: it receives an \texttt{SExpr}, it modifies its state depending on the variant of s-expression that it received, and returns either the resulting memory address of the expression, or a compiler error.
  \item \texttt{compile\_lambda}: This method recieves a list of argument names (of the function that will be compiled) and an \texttt{SExpr} that contains the body of the function
  \item \texttt{write\_to}: This method is used to serialize the compiler state into its string representation, first writing the constants table to the file, and then writing all the instructions in order. More information about this representation can be found in section \ref{comp:bytecode}
  \item \texttt{into\_parts}: Finally, this method is used when the compiler state, instead of being printed to a file, is decomposed to create the state of a VM. It returns the constants and the instructions of the compiler
\end{itemize}

\section{Bytecode representation}
\label{comp:bytecode}
A bytecode file produced by the \texttt{miniclj} compiler, with the extension \texttt{.mclj}, is composed of two parts separated by a line with three asterisks: a list of constant and memory address pairs and a list of instructions. The pairs from the first part are only separated by a space.

\subsection{Constants}
The constants, defined in file \path{miniclj-lib/src/constant.rs}, have 5 different variants:
\begin{itemize}
  \item \texttt{Callable}: Stores a reference to a builtin callable
  \item \texttt{Lambda}: Has two fields: the instruction pointer that the VM must jump to to execute the lambda, and the number of arguments that the lambda accepts
  \item \texttt{String}: Stores a string literal inside
  \item \texttt{Number}: Stores a \texttt{Rational64} struct inside (\texttt{num}'s implementation of fraction between two signed integers of 64 bits)
  \item \texttt{Nil}: The nil value
\end{itemize}

They are serialized (and deserialized) pretty easily:
\begin{itemize}
  \item \texttt{Callable}: Only the callable name is stored
  \item \texttt{Lambda}: Both numbers are inserted after the string "fn", separated by the at sign (@)
  \item \texttt{String}: The string literal is printed between double quotes
  \item \texttt{Number}: The denominator is printed, then a slash (/) and finally the numerator
  \item \texttt{Nil}: The string "nil" is printed (without quotes)
\end{itemize}

\subsection{Memory addresses}
Memory addresses are composed of two fields:
\begin{itemize}
  \item A \texttt{lifetime} field, of type \texttt{Lifetime}, which specifies the scope of the address. It can be either constant, global, local or temporal.
  \item The index of the address (represented by an unsigned integer)
\end{itemize}

They are serialized as unsigned 32 bit integers, where the first 4 bytes are reserved for the lifetime (constant being $1 * (2 << 28)$, global $2 * (2 << 28)$, and so on), and the other 28 bits are reserved for the index of the variable. The string representation of these addresses is just the number printed as is.

\subsection{Instructions}
The enum \texttt{Instruction} represents the type of instructions that the VM can execute. It has 6 variants and it is declared on the file \path{miniclj-lib/src/instruction.rs}. Here's a short description of each type:
\begin{itemize}
  \item \texttt{Call}: Has 3 fields: the memory address of the callable, the list of memory addresses of the arguments, and the memory address where the result should be stored. This instruction is serialized starting with the string "call", then the address of the callable, the arguments and the result, separated by spaces
  \item \texttt{Return}: This instruction represents the return instruction from a lambda function, and it stores only the memory address of the value that the function will return. It is serialized as the keyword "ret", a space, and then the address
  \item \texttt{Assignment}: This instruction is used to copy a value from an address to another one. It stores the source and destination addresses, and is serialized starting with the keyword "mov", a space, the source address, another space, and the destination address
  \item \texttt{Jump}: This instruction represents an inconditional jump, and it stores only the instruction pointer to which the virtual machine should jump to. It is serialized using the word "jmp", a space, and the instruction pointer
  \item \texttt{JumpOnTrue}: This instruction is used when a jump should only be executed if a value is true. It stores the memory address of the value it should check and the instruction pointer it should jump to, and it is serialized with the keyword "jmpT", a space, the address, another space, and the instruction pointer
  \item \texttt{JumpOnFalse}: This instruction is almost the same as the last one, but only executing the jump if the value referenced by the memory address is false, and with being serialized with the keyword "jmpF"
\end{itemize}


\chapter{About the virtual machine}

\section{Tools and libraries}
The virtual machine, also implemented in Rust, uses the same dependencies as the compiler through the \texttt{num} callable that parses a number from a string, plus the module \texttt{escape8259}, that exports a function used to escape some characters (like \texttt{$\backslash$n} to a newline character) when calling \texttt{print} or \texttt{println}.

\section{Execution}
The execution state is stored in the \texttt{VMState} structure, declared in file \path{miniclj-lib/src/vm/state.rs}. This structure is composed of 3 fields:
\begin{itemize}
  \item \texttt{constants}: A map of memory addresses to constants, read and constructed from the first part of the bytecode representation
  \item \texttt{instructions}: A vector of instructions, read from the second part of the bytecode file
  \item \texttt{global\_scope}: This field is implemented as a custom structure named \texttt{Scope} (declared in file \path{miniclj-lib/src/vm/scope.rs}), and it is composed of two vectors of values: one for declared variables and one for temporal values. This structure is used for global and local variables declared in the root scope, and a new \texttt{Scope} is created when executing user defined functions with local variables
\end{itemize}

The main function of the structure \texttt{VMState} is \texttt{execute}, which calls a private method named \texttt{inner\_execute}, implemented as a big match expression (like a switch statement) over the instructions that the virtual machine accepts.

Another important method is \texttt{execute\_lambda} which, as the name implies, executes a lambda function defined by the user. It starts by checking the arity of the function, then creates a new \texttt{Scope}, inserts the local parameters at the start of the scope and also calls \texttt{inner\_execute}.

\section{Memory representation}
As described earlier, values are stored inside two vectors in structure \texttt{Scope}. This structure has 4 methods: two \texttt{get} methods for temporal values and variables, which accept an index and return either the value of the vector at that index, or a \texttt{RuntimeError::CompilerError} when the value wasn't found; and two \texttt{store} methods, also for temporal values and variables, which receive an index and a \texttt{Value}, which is then stored in the corresponding vector.

The \texttt{get} methods from \texttt{Scope} are called by a \texttt{get} method in \texttt{VMState}, which receives a reference to the current scope and a memory address, and then routes the request depending on the lifetime of the memory address:
\begin{itemize}
  \item In case that it has a \texttt{Constant} lifetime, this method checks the \texttt{constants} field in \texttt{VMState}
  \item If the address has a \texttt{GlobalVar} lifetime, it checks the \texttt{global\_scope} field also in \texttt{VMState}
  \item If the address has either a \texttt{LocalVar} or \texttt{Temporal} lifetime, the request is routed to the current scope passed to the function
\end{itemize}

The same process happens with the \texttt{store} function in \texttt{Scope}: \texttt{VMState} has a method called \texttt{store} which routes its requests depending on the lifetime of the address, with an exception for \texttt{Constant} addresses, which aren't supposed to be modified during runtime.


\chapter{Code examples}

\section{Cyclic factorial function}
\subsection{minclj code}
\inputminted{clojure}{/home/mario/git/MarioJim/miniclj/examples/cyclic_factorial.clj}

\subsection{Bytecode}
\inputminted{text}{/home/mario/git/MarioJim/miniclj/examples/cyclic_factorial.mclj}

\subsection{Output}
\begin{minted}{text}
The factorial of 15 is 1307674368000
Finished in 26ms
\end{minted}


\section{Recursive factorial function}
\subsection{minclj code}
\inputminted{clojure}{/home/mario/git/MarioJim/miniclj/examples/recursive_factorial.clj}

\subsection{Bytecode}
\inputminted{text}{/home/mario/git/MarioJim/miniclj/examples/recursive_factorial.mclj}

\subsection{Output}
\begin{minted}{text}
The factorial of 15 is 1307674368000
Finished in 32ms
\end{minted}


\section{Cyclic Fibonacci function}
\subsection{minclj code}
\inputminted{clojure}{/home/mario/git/MarioJim/miniclj/examples/cyclic_fibonacci.clj}

\subsection{Bytecode}
\inputminted{text}{/home/mario/git/MarioJim/miniclj/examples/cyclic_fibonacci.mclj}

\subsection{Output}
\begin{minted}{text}
The Fibonacci number 15 is 610
Finished in 27ms
\end{minted}


\section{Recursive Fibonacci function}
\subsection{minclj code}
\inputminted{clojure}{/home/mario/git/MarioJim/miniclj/examples/recursive_fibonacci.clj}

\subsection{Bytecode}
\inputminted{text}{/home/mario/git/MarioJim/miniclj/examples/recursive_fibonacci.mclj}

\subsection{Output}
\begin{minted}{text}
The Fibonacci number 15 is 610
Finished in 143ms
\end{minted}


\section{Find an element in a list}
\subsection{minclj code}
\inputminted{clojure}{/home/mario/git/MarioJim/miniclj/examples/find_in_list.clj}

\subsection{Bytecode}
\inputminted{text}{/home/mario/git/MarioJim/miniclj/examples/find_in_list.mclj}

\subsection{Output}
\begin{minted}{text}
List: '(2 6 8 4 3 5)
Found element 3 in position 4
Finished in 26ms
\end{minted}

\section{Sorting a list}
\subsection{minclj code}
% \inputminted{clojure}{/home/mario/git/MarioJim/miniclj/examples/find_in_list.clj}

\subsection{Bytecode}
% \inputminted{text}{/home/mario/git/MarioJim/miniclj/examples/find_in_list.mclj}

\subsection{Output}
% \begin{minted}{text}
% \end{minted}

\section{Matrix multiplication}
\subsection{minclj code}
\inputminted{clojure}{/home/mario/git/MarioJim/miniclj/examples/matrix_multiplication.clj}

\subsection{Bytecode}
\inputminted{text}{/home/mario/git/MarioJim/miniclj/examples/matrix_multiplication.mclj}

\subsection{Output}
% \begin{minted}{text}
% \end{minted}

\chapter{Project structure}
The project is structured in 4 different folders; 3 Rust crates part of the root workspace, and one Next.js project:

\section{\texttt{miniclj-lib}}
This crate stores the main logic for the compiler, virtual machine and the shared code between them. This crate's unit tests are run for every new commit pushed to the main branch of the repo in a GitHub Actions worker, following the continuous integration pipeline described in the file \texttt{.github/workflows/ci.yml}.

\section{\texttt{miniclj}}
This crate stores only a couple of files; it exposes the compiler and vm functionality through a Command Line Interface. This crate compiles to an executable that can be called using the following subcommands for a different function each:
\begin{itemize}
  \item \texttt{check}: Check if a source code file can be correctly parsed 
  \item \texttt{ast}: Print the abstract syntax tree from a source code file
  \item \texttt{build}: Compile a source code file into a bytecode file
  \item \texttt{exec}: Execute a bytecode file
  \item \texttt{run}: Compile and execute a source code file
\end{itemize}

\section{\texttt{miniclj-wasm}}
This crate compiles to a binary WebAssembly file, and exposes the functionality of the compiler and vm through JavaScript bindings so that they can be ran in a browser context. It exposes three functions, where each one accepts a string as the input code, and outputs either an structure with the output of the function or an error:
\begin{itemize}
  \item \texttt{ast}: This function prints the abstract syntax tree parsed from the code
  \item \texttt{compile}: This function compiles the code and outputs the corresponding bytecode
  \item \texttt{run}: This function compiles and executes the code, but with the following adaptations for the browser context:
  \begin{itemize}
    \item \texttt{read} calls are executed as \texttt{window.prompt} calls, where the browser displays an alert with a text input, which is then redirected to the program 
    \item \texttt{print} and \texttt{println} instructions append its output to the global variable \\\texttt{window.minicljoutput}
  \end{itemize}
\end{itemize}

\section{\texttt{playground}}
This folder stores a simple, one page Next.js project where the \texttt{miniclj-wasm} is imported and executed for the code written in left side panel, and the output or the error for every function is displayed on the right side panel. The playground is built using GitHub Actions for each commit to the repo, following the continuous delivery pipeline described in the file \texttt{.github/workflows/cd.yml}


\appendix

\chapter{Commit log}
\label{apdx:commits}
\inputminted{text}{/home/mario/git/MarioJim/miniclj/docs/commits.txt}

\chapter{Weekly logs in Spanish}
\label{apdx:weeklylogs}
\inputminted[breaklines=true]{md}{/home/mario/git/MarioJim/miniclj/docs/logs.md}

\chapter{Language grammar}
\label{apdx:grammar}
\inputminted{rust}{/home/mario/git/MarioJim/miniclj/miniclj-lib/src/lispparser.lalrpop}


\end{document}